#!/usr/bin/perl

# s3 command - script for manipulating files on Amazon AWS S3 service

# Copyright (c) 2008, Oliver Crow
# See License.txt for terms of use

use Net::Amazon::S3;
use Text::Wrap;
use File::stat;
use strict;

my (%config, $s3, $cmd);

sub usage_quit {
    my ($message) = @_;
    print "\n$message\n" unless ($message eq '');
    print "\nusage: $0 <command> [parameters]\n";
    print "commands:\n";
    print "   ls                     - list buckets\n";
    print "   ls <bucket> [prefix]   - list files\n";
    print "   ll <bucket> [prefix]   - list files in long format\n";
    print "   get <bucket> <file>    - get file from S3\n";
    print "   put <bucket> <file>    - put file to S3\n";
    print "   rm <bucket> <file>     - remove a file from S3\n";
    print "   info <bucket> <file>   - get metadata for a file from S3\n";
    print "   diff <bucket> <file>   "
        . "- compare local file with stored S3 checksum\n";
    print "   update <bucket> <file> - put file to S3 if it has changed\n";
    print "   mkbucket <bucket>      - create a bucket\n";
    print "   rmbucket <bucket>      - remove an empty bucket\n";
    print "\n";
    exit(1);
}

sub argv_bucket_and_file {
    # get a bucket name and a file name from the command arguments, or die
    if (scalar(@ARGV) < 2) {
        print STDERR "usage: $0 $cmd <bucket> <file>\n";
    }
    return (shift @ARGV, shift @ARGV);
}

sub argv_bucket_name {
    # get a bucket name from the command arguments, or die
    if (scalar(@ARGV) == 0) {
        print STDERR "usage: $0 $cmd <bucket>\n";
        exit(1);
    }
    return shift @ARGV;
}

sub get_config {
    my $rcfile = "$ENV{'HOME'}/.s3rc";
    open RC, $rcfile
        or die "Couldn't open config file '$rcfile'";
    while(<RC>) {
        m/(\S+)\s*:\s*(\S+)/;
        $config{$1} = $2;
    }
    close RC;
    if (!defined($config{'aws_access_key_id'})) {
        die "Config file didn't define aws_access_key_id";
    }
    if (!defined($config{'aws_secret_access_key'})) {
        die "Config file didn't define aws_secret_access_key";
    }
}

sub open_s3 {
    $s3 = Net::Amazon::S3->new({
        aws_access_key_id => $config{'aws_access_key_id'},
        aws_secret_access_key => $config{'aws_secret_access_key'},
        retry => 1
    });
}

sub s3_error {
    print "S3 Error: " . $s3->err . "\n";
    print wrap("", "", $s3->errstr) . "\n";
    exit(1);
}

sub error {
    my ($msg) = @_;
    print STDERR $msg . "\n";
    exit(1);
}

sub file_mtime {
    # get file modification date
    my ($file_name) = @_;
    return (stat $file_name)->mtime;
}

sub list_files { 
    if (scalar(@ARGV) > 0) {
        my $bucket_name = $ARGV[0];
        my %params;

        my $response = $s3->list_bucket_all({
            'bucket' => $bucket_name,
            'prefix' => $ARGV[1]
        }) or s3_error();

        exists $response->{bucket}
            or error("No such bucket '$bucket_name'");

        foreach my $key (@{$response->{keys}}) {
            if ($cmd eq 'll') {
                my $date = $key->{last_modified};
                $date =~ s/T/ /; $date =~ s/\.\d\d\dZ//;
                printf("%10d  %s  %s\n", 
                    $key->{size}, $date, $key->{key});
            } else {
                printf("%s\n", $key->{key});
            }
        }
    } else {
        # list buckets
        my $buckets = $s3->buckets
            or s3_error();
        foreach my $bucket (@{$buckets->{buckets}}) {
            print $bucket->bucket . "\n";
        }
    }
}

sub get_file { 
    my ($bucket_name, $file_name) = argv_bucket_and_file();

    ! -e $file_name or error("File '$file_name' already exists");

    my $bucket=$s3->bucket($bucket_name);
    my $meta_data = $bucket->head_key($file_name);

    # get file contents
    $bucket->get_key_filename($file_name, "GET", $file_name)
        or s3_error();

    my $remote_mtime = $meta_data->{'x-amz-meta-file-mtime'};
    if (defined($remote_mtime)) {
        utime time, $remote_mtime, $file_name;
    }
}

sub put_file {
    my ($bucket_name, $file_name) = argv_bucket_and_file();
    send_file($bucket_name, $file_name);
}

sub send_file { 
    my ($bucket_name, $file_name) = @_;

    -f $file_name or error("No such file '$file_name'");
    -r $file_name or error("Can't read file '$file_name'");
    ! -z $file_name or error("File '$file_name' is empty");

    # get file modification date
    my $mtime = file_mtime($file_name);

    my $bucket=$s3->bucket($bucket_name);

    $bucket->add_key_filename($file_name, $file_name, {
        'x-amz-meta-file-mtime' => $mtime})
        or s3_error();
}

sub update_file {
    # send file to S3 if it isn't already there or if it has changed
    # as determined by file size and modification date 

    my ($bucket_name, $file_name) = argv_bucket_and_file();

    -f $file_name or error("File '$file_name' doesn't exist locally");
    -r $file_name or error("File '$file_name' isn't readable");

    my $bucket=$s3->bucket($bucket_name);
    my $meta_data = $bucket->head_key($file_name);

    # file doesn't exist on S3, so send it
    if (!defined($meta_data)) {
        send_file($bucket_name, $file_name);
        return;
    }
    
    # compare local and remote file sizes and modification times
    my $local_size = (-s $file_name);
    my $local_mtime = file_mtime($file_name);

    my $remote_size = $meta_data->{content_length};
    my $remote_mtime = $meta_data->{'x-amz-meta-file-mtime'};

    if ($local_size != $remote_size || $local_mtime ne $remote_mtime) {
        send_file($bucket_name, $file_name);
    }
}

sub remove_file { 
    my ($bucket_name, $file_name) = argv_bucket_and_file();
    
    my $bucket=$s3->bucket($bucket_name);
    $bucket->delete_key($file_name)
        or s3_error();
} 

sub file_info {
    my ($bucket_name, $file_name) = argv_bucket_and_file();
    my $bucket=$s3->bucket($bucket_name);
    my $meta_data = $bucket->head_key($file_name);

    if (!defined($meta_data)) { 
        error("File '$file_name' doesn't exist on S3"); 
    }
    foreach my $key (keys %$meta_data) {
        print "$key: $meta_data->{$key}\n" 
            unless ($key eq "value");
    }
}

sub diff_file {
    # compare local file with version on S3 using file sizes and MD5 checksums
    # to determine if the files differ
    use Digest::MD5;
    my ($bucket_name, $file_name) = argv_bucket_and_file();
    
    -f $file_name or error("File '$file_name' doesn't exist locally");
    -r $file_name or error("File '$file_name' isn't readable");

    my $bucket=$s3->bucket($bucket_name);
    my $meta_data = $bucket->head_key($file_name);

    defined($meta_data) or error("File '$file_name' doesn't exist on S3"); 

    # compare file sizes
    my $local_size = (-s $file_name);
    my $remote_size = $meta_data->{content_length};

    if ($local_size != $remote_size) {
        printf STDERR "Files differ in size\nlocal:  %10d\nremote: %10d\n", 
            $local_size, $remote_size;
        exit(2);
    }

    # compare MD5 checksums
    my $remote_md5 = $meta_data->{etag};
    open FILE, $file_name or error("Can't read file '$file_name': $!");
    binmode FILE;
    my $md5 = Digest::MD5->new;
    $md5->addfile(*FILE);
    my $local_md5 = $md5->hexdigest;

    if ($local_md5 ne $remote_md5) {
        printf STDERR "File checksums differ\nlocal:  %s\nremote: %s\n",
            $local_md5, $remote_md5;
        exit(2);
    }
}

sub make_bucket {
    my $bucket_name = argv_bucket_name();
    $s3->add_bucket( { bucket => $bucket_name } ) or s3_error();
}

sub remove_bucket { 
    my $bucket_name = argv_bucket_name();
    my $bucket=$s3->bucket($bucket_name);
    $bucket->delete_bucket or s3_error();
}

my %commands = (
    'ls'   => \&list_files,
    'll'   => \&list_files,
    'info' => \&file_info,
    'get'  => \&get_file,
    'put'  => \&put_file,
    'rm'   => \&remove_file,
    'diff' => \&diff_file,
    'update' => \&update_file,
    'mkbucket' => \&make_bucket,
    'rmbucket' => \&remove_bucket,
);

$cmd = shift @ARGV;
if (!defined($cmd)) {
    usage_quit();
}

get_config();
open_s3();

if (defined($commands{$cmd})) {
    $commands{$cmd}->();
} else {
    print STDERR "Unknown command '$cmd'\n";
    exit(1);
}
